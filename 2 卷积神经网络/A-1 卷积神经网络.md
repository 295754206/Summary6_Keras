#### CNN相关概念

* 卷积神经网络是依序使用卷积与池化运算来执行特征萃取，可以侦测出图片中拥有的 **样式**（Pattern），这个样式通常指的是过滤器
* 卷积运算 + 池化运算 => 特征萃取

#### MLP和CNN的区别

* MLP学习的是全域样式
* CNN的卷积层是使用过滤器的小区域来萃取特征，学习到的是局部样式

#### 卷积层和全连接层有何不同

* 如果输入图片的尺寸是100x100，输入层就是10000个向量，如果下一层是隐藏层神经元数是100，则10000x100+100参数量太大
* 局部链接：传统神经网络是一种全连接，CNN的神经层学习的是区域样式
* 权重共享：每一组局部链接的神经元都是使用相同的权重

#### 卷积神经网络能做什么

* 擅长处理可以转换成图片格式的空间资料，如NLP文字资料，录音的按时间排序的组合频率资料（空间位置有意义）



#### 卷积运算

​        输入图片点阵图：5x5 ,  过滤器点阵图：3x3,   用过滤器从左上逐元素移动，进行点乘运算（获取乘积和），放入特征图的第一元素位置，后面逐次，最后获得特征图。卷积层的权重就是过滤器，CNN学的就是卷积层的权重，即过滤器

​        卷积的作用是学习到特征

#### 池化运算

​        池化运算可以压缩和保留特征图的重要资讯，常用的是最大池化法（MaxPooling），即取窗格中各元素的最大值。需要指定滑动窗格大小，stride为2则为2x2窗格，周边不足一般补0

​        池化的作用是提取最强特征，解决图片小范围内的不稳定的平移、缩放、旋转、变形，并从局部特征拉开视野看到全域特征（组合卷积学到的各个特征）

#### 平坦化

​        简单理解就是把矩阵转换为一维数组，方便进入全连接层

#### Dropout层

​        Dropout可在不增加训练资料的情况下对抗过度拟合，一般放在 卷积+池化 系列的后面，全连接层的前面，最后是输出层

​        Dropout的目的是在损失函数加入随机性和破坏各层神经元之间的共适性（希望每个神经元都可以独立探测出有价值的特征而不受其它神经元影响）



#### 卷积层输入与输出（多维资料）

* 一张图片是由3D张量（宽度，高度，色彩数）组成，则输入通道和过滤器通道数都是3，灰阶图片通道数是1
* 过滤器的通道数和卷积层的输入通道数相同
* 卷积层的输出通道数取决于过滤器数量

#### 特征图尺寸

​    输入资料：W x W，过滤器：F x F，步幅（每次移动的步数）：S    

​    尺寸 = （ W - F ）/ S + 1

#### 解决图片越来越小

​    在原始图片四周补0，这样可以保持输入和输出的图片尺寸相同

​    补0的维数：P

​    特征图尺寸 = （ W - F + 2P ）/ S + 1



#### 自编码器（Autoencoder, AE）

* 原始图片（28x28）→  编码器  →  压缩图片（6x6）→  解码器  →  还原图片（28x28）

* 主要特点：

  * 只适用于特定资料：只适用于与训练资料集相似的资料来压缩

  * 资料损失：会有损失，会和原始图片不完全一样

  * 非监督式学习：从自己的资料中学习，自我监督式学习，是和自己的损失来比较 

* 在应用上：

  * 应用于机器学习的**主成分分析**，减少维度，保留主要特征，这是一种降维的特征拮取
  * 当CNN需要处理尺寸很大的图片时，可以先建立自编码器来降维取出主要特征，用主要特征来进行学习

* 使用Functional API定义模型（物件写法）

  ```python
  from tensorflow.keras.models import Model
  from tensorflow.keras.layers import Input, Dense
  
  inputs = Input(shape=(8,))
  hidden1 = Dense(10, activation="relu")(inputs)
  hidden2 = Dense(8, activation="relu")(hidden1)
  outputs = Dense(1, activation="sigmoid")(hidden2)
  model = Model(inputs=inputs, outputs=outputs)
  model.summary() 
  ```

  多输入和多输出模型：

  ```python
  model = Model(inputs=[a1,a2], outputs=[b1,b2,b3])
  ```

  



